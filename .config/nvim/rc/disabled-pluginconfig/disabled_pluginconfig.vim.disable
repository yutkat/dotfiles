"===============================================================
"          Disable Plugin Settings                           {{{
"===============================================================

"==============================
" etc                       {{{
"==============================

"-------------------------------
" vim-operator-flashy
if IsPluginInstalled('vim-operator-flashy')
  map y <Plug>(operator-flashy)
  nmap Y <Plug>(operator-flashy)$
endif

"-------------------------------
" targets.vim
if IsPluginInstalled('targets.vim')
endif

"-------------------------------
" vim-autosave
if IsPluginInstalled('vim-autosave')
  let g:autosave_backup = expand('~/.local/share/nvim/backup')
endif

"-------------------------------
" vim-workspace
if IsPluginInstalled('vim-workspace')
  let g:workspace_session_directory = $HOME . '/.local/share/nvim/sessions/'
  let g:workspace_undodir= $HOME . '/.local/share/nvim/undodir'
  let g:workspace_autosave_always = 1
endif

"-------------------------------
" you-are-here.vim
if IsPluginInstalled('you-are-here.vim')
  nnoremap <Leader>- <Cmd>call you_are_here#Toggle()<CR>
endif

"-------------------------------
" vim-wordmotion
if IsPluginInstalled('vim-wordmotion')
  let g:wordmotion_prefix = '[SubLeader]'
endif

"-------------------------------
" vim-autocorrect
if IsPluginInstalled('vim-autocorrect')
  augroup vimrc_autocorrect
    autocmd!
    autocmd FileType markdown,mkd call AutoCorrect()
  augroup END
endif

"-------------------------------
" vim-litecorrect
if IsPluginInstalled('vim-litecorrect')
  augroup vimrc_litecorrect
    autocmd!
    autocmd FileType markdown,mkd call litecorrect#init()
  augroup END
endif

"-------------------------------
" context.vim
if IsPluginInstalled('context.vim')
  let g:context_enabled = 0
  let g:context_add_mappings = 0
endif

"-------------------------------
" vim-subversive
if IsPluginInstalled('vim-subversive')
  nmap <Leader>s <plug>(SubversiveSubstituteRange)
  xmap <Leader>s <plug>(SubversiveSubstituteRange)
  nmap <Leader>ss <plug>(SubversiveSubstituteWordRange)
endif

"-------------------------------
" vim-yoink
if IsPluginInstalled('vim-yoink')
  nmap <C-n> <plug>(YoinkPostPasteSwapBack)
  nmap <C-p> <plug>(YoinkPostPasteSwapForward)
  nmap p <plug>(YoinkPaste_p)
  nmap P <plug>(YoinkPaste_P)
endif

"-------------------------------
" vim-qfstatusline
if IsPluginInstalled('vim-qfstatusline')
  let g:Qfstatusline#UpdateCmd = function('lightline#update')
endif

"-------------------------------
" rainbow_csv
if IsPluginInstalled('rainbow_csv')
  let g:disable_rainbow_key_mappings = 1
endif

"-------------------------------
" float-preview.nvim
if IsPluginInstalled('float-preview.nvim')
  let g:float_preview#docked = 0
endif

"-------------------------------
" repmo-vim
if IsPluginInstalled('repmo-vim')
  map <expr> , repmo#LastKey(';')|sunmap ,
endif

"-------------------------------
" vim-illuminate
if IsPluginInstalled('vim-illuminate')
  let g:Illuminate_ftblacklist = ['nerdtree']
endif

"-------------------------------
" vim-terraform
if IsPluginInstalled('vim-terraform')
  let g:terraform_fmt_on_save = 1
endif

"-------------------------------
" vim-markdown
if IsPluginInstalled('vim-markdown')
  let g:vim_markdown_folding_disabled = 1
  let g:markdown_enable_mappings = 0
  let g:vim_markdown_conceal = 0
  let g:vim_markdown_no_default_key_mappings = 1
endif

"-------------------------------
" vim-sonictemplate
if IsPluginInstalled('vim-sonictemplate')
  let g:sonictemplate_vim_template_dir = ['~/.vim/template']
endif

"-------------------------------
" delimitMate
if IsPluginInstalled('delimitMate')
  let delimitMate_smart_quotes = '\%(\w\|[^[:punct:][:space:]]\|\%(\\\\\)*\\\)\%#\|\%#\%(\w\|[^[:space:][:punct:]]\)'
  let delimitMate_smart_matchpairs = '^\%(\S\|\!\|[£$]\|[^[:space:][:punct:]]\)'
endif

"-------------------------------
" ale
if IsPluginInstalled('ale')
  let g:ale_completion_enabled = 0
  let g:ale_rust_cargo_use_clippy = 1
  let g:ale_set_loclist = 0
endif

"-------------------------------
" is.vim
if IsPluginInstalled('is.vim')
  if IsPluginInstalled('vim-anzu')
    map n <Plug>(is-nohl)<Plug>(anzu-n-with-echo)
    map N <Plug>(is-nohl)<Plug>(anzu-N-with-echo)
  endif
  if IsPluginInstalled('vim-asterisk')
    map *  <Plug>(asterisk-z*)<Plug>(is-nohl-1)
    map g* <Plug>(asterisk-gz*)<Plug>(is-nohl-1)
    map #  <Plug>(asterisk-z#)<Plug>(is-nohl-1)
    map g# <Plug>(asterisk-gz#)<Plug>(is-nohl-1)
  endif
endif

"-------------------------------
" camelcasemotion
if IsPluginInstalled('camelcasemotion')
  map <silent> [SubLeader]w <Plug>CamelCaseMotion_w
  map <silent> [SubLeader]b <Plug>CamelCaseMotion_b
  map <silent> [SubLeader]e <Plug>CamelCaseMotion_e
  map <silent> [SubLeader]ge <Plug>CamelCaseMotion_ge
endif

"-------------------------------
" ListToggle
if IsPluginInstalled('ListToggle')
  let g:lt_location_list_toggle_map = '<LocalLeader>l'
  let g:lt_quickfix_list_toggle_map = '<LocalLeader>q'
endif

"-------------------------------
" vim-togglelist
if IsPluginInstalled('vim-togglelist')
  nmap <script> <LocalLeader>l <Cmd>call ToggleLocationList()<CR>
  nmap <script> <LocalLeader>q <Cmd>call ToggleQuickfixList()<CR>
  let g:toggle_list_copen_command='botright copen'
endif

"-------------------------------
" vim-hopping
if IsPluginInstalled('vim-hopping')
  " Example key mapping
  nmap <Space>/ <Plug>(hopping-start)
  " Keymapping
  let g:hopping#keymapping = {
        \   "\<C-n>" : '<Over>(hopping-next)',
        \   "\<C-p>" : '<Over>(hopping-prev)',
        \   "\<C-u>" : '<Over>(scroll-u)',
        \   "\<C-d>" : '<Over>(scroll-d)',
        \}
endif

"-------------------------------
" autopreview
if IsPluginInstalled('autopreview')
  let g:AutoPreview_enabled =0
  set updatetime=100
  set previewheight =8
  nnoremap [SubLeader]t <Cmd>AutoPreviewToggle<CR>
endif

"-------------------------------
" vim-trailing-whitespace
if IsPluginInstalled('vim-trailing-whitespace')
  let g:extra_whitespace_ignored_filetypes =
        \ ['unite', 'markdown', 'vimfiler', 'qf',
        \ 'tagbar', 'nerdtree', 'vimshell', 'minimap']
  augroup vimrc_trailing_whiteSpace
    autocmd!
    autocmd BufWritePre * :FixWhitespace
  augroup END
endif

"-------------------------------
" vim-choosewin
if IsPluginInstalled('vim-choosewin')
  nmap  <Leader>-  <Plug>(choosewin)
  " オーバーレイ機能を有効にしたい場合
  let g:choosewin_overlay_enable          = 1
  " オーバーレイ・フォントをマルチバイト文字を含むバッファでも綺麗に表示する。
  let g:choosewin_overlay_clear_multibyte = 1
endif

"-------------------------------
" incsearch.vim
if IsPluginInstalled('incsearch.vim')
  map /  <Plug>(incsearch-forward)
  map ?  <Plug>(incsearch-backward)
  map g/ <Plug>(incsearch-stay)

  augroup vimrc_incsearch
    autocmd!
    autocmd VimEnter * call s:incsearch_keymap()
  augroup END
  function! s:incsearch_keymap() abort
    "IncSearchNoreMap <Right> <Over>(incsearch-next)
    "IncSearchNoreMap <Left>  <Over>(incsearch-prev)
    "IncSearchNoreMap <Down>  <Over>(incsearch-scroll-f)
    "IncSearchNoreMap <Up>    <Over>(incsearch-scroll-b)
    IncSearchNoreMap <Tab>   <Over>(buffer-complete)
    IncSearchNoreMap <S-Tab> <Over>(buffer-complete-prev)
  endfunction
endif

"-------------------------------
" incsearch-fuzzy.vim
if IsPluginInstalled('incsearch-fuzzy.vim')
  map z/ <Plug>(incsearch-fuzzy-/)
  map z? <Plug>(incsearch-fuzzy-?)
  map zg/ <Plug>(incsearch-fuzzy-stay)
endif

"-------------------------------
" spelunker.vim
if IsPluginInstalled('spelunker.vim')
  let g:enable_spelunker_vim = 1
  " override
  command! AddCorrectSpell execute "normal Zg"
  command! AddWrongSpell  execute "normal Zw"
  command! ChangeCorrectSpell  execute ':call feedkeys("Z=")'
  command! FixCorrectSpell  execute ':ChangeCorrectSpell'
  command! CorrectSpell  execute ':ChangeCorrectSpell'
endif

"-------------------------------
" scrollbar.nvim
if IsPluginInstalled('scrollbar.nvim')
  augroup vimrc_scrollbar
    autocmd!
    autocmd CursorMoved,VimResized,QuitPre * silent! lua require('scrollbar').show()
    autocmd WinEnter,FocusGained           * silent! lua require('scrollbar').show()
    autocmd WinLeave,FocusLost             * silent! lua require('scrollbar').clear()
  augroup END
endif

"-------------------------------
" vim-clap
if IsPluginInstalled('vim-clap')
  function! s:clap_my_keymap() abort
    inoremap <silent> <buffer> <Down> <C-R>=clap#handler#navigate_result('down')<CR>
    inoremap <silent> <buffer> <Up> <C-R>=clap#handler#navigate_result('up')<CR>
  endfunction
  augroup vimrc_clap
    autocmd!
    autocmd User ClapOnEnter   call s:clap_my_keymap()
    " autocmd User ClapOnExit    call YourFunction()
  augroup END
  nnoremap <unique> <Leader><Leader>bc <Cmd>Clap bcommits<CR>
  nnoremap <unique> <Leader><Leader>l <Cmd>Clap blines<CR>
  nnoremap <unique> <Leader><Leader>b <Cmd>Clap buffers<CR>
  " nnoremap <unique> <Leader><Leader> <Cmd>Clap colors<CR>
  nnoremap <unique> <Leader><Leader>h <Cmd>Clap hist<CR>
  nnoremap <unique> <Leader><Leader>c <Cmd>Clap commits<CR>
  nnoremap <unique> <Leader><Leader>f <Cmd>Clap files<CR>
  " nnoremap <unique> <Leader><Leader> <Cmd>Clap filetypes<CR>
  nnoremap <unique> <Leader><Leader>p <Cmd>Clap git_files<CR>
  nnoremap <unique> <Leader><Leader>g <Cmd>Clap grep<CR>
  nnoremap <unique> <Leader><Leader>j <Cmd>Clap jumps<CR>
  nnoremap <unique> <Leader><Leader>m <Cmd>Clap marks<CR>
  nnoremap <unique> <Leader><Leader>t <Cmd>Clap tags<CR>
  " nnoremap <unique> <Leader><Leader> <Cmd>Clap windows<CR>
endif

"-------------------------------
" asyncomplete.vim
if IsPluginInstalled('asyncomplete.vim')
  inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
  inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<cr>"
  let g:asyncomplete_remove_duplicates = 1
  let g:asyncomplete_smart_completion = 1
  let g:asyncomplete_auto_popup = 1
  set completeopt+=preview
  augroup vimrc_asynccomplete
    autocmd!
    autocmd CompleteDone * if pumvisible() == 0 | pclose | endif
  augroup END
endif

"-------------------------------
" vim-xtabline
if IsPluginInstalled('vim-xtabline')
  " let g:xtabline_lazy = 1
  let g:xtabline_settings = {}
  let g:xtabline_settings.tabline_modes = ['buffers', 'tabs', 'arglist']
  let g:xtabline_settings.buffer_filtering = 0
  let g:xtabline_settings.relative_paths = 0
  let g:xtabline_settings.use_tab_cwd = 0
  let g:xtabline_settings.theme = 'codedark'
  nnoremap <xtabline>   <Nop>
  nmap    X <xtabline>
  let g:xtabline_settings.map_prefix = '<xtabline>'
  " let g:xtabline_settings.enable_mappings = 1
  let g:xtabline_settings.bufline_format = ' N I< l +'
  let g:xtabline_settings.recent_buffers = 99
  let g:xtabline_settings.tab_number_in_buffers_mode = 0
  let g:xtabline_settings.sessions_path = $HOME . '/.local/share/nvim/session'
  let g:xtabline_settings.bookmarks_file = $HOME . '/.local/share/nvim/.XTablineBookmarks'
  let g:xtabline_settings.sessions_data = $HOME . '/.local/share/nvim/.XTablineSessions'
  nmap <F2> <Cmd>if vimrc#is_normal_buffer() <Bar> execute v:count1 "XTabPrevBuffer" <Bar> endif <CR>
  nmap <F3> <Cmd>if vimrc#is_normal_buffer() <Bar> execute v:count1 "XTabNextBuffer" <Bar> endif <CR>
  nmap H <Cmd>if vimrc#is_normal_buffer() <Bar> execute v:count1 "XTabPrevBuffer" <Bar> endif <CR>
  nmap L <Cmd>if vimrc#is_normal_buffer() <Bar> execute v:count1 "XTabNextBuffer" <Bar> endif <CR>
  nmap <F4> <Cmd>XTabCloseBuffer<CR><Cmd>XTabPurge<CR>
  nmap <C-x> <Cmd>XTabCloseBuffer<CR><Cmd>XTabPurge<CR>
  nmap <S-F4> <Cmd>XTabCloseBuffer<CR><Cmd>XTabPurge<CR>
  nmap <C-F4> <Cmd>XTabCloseBuffer<CR><Cmd>XTabPurge<CR>
  nmap <C-S-F2> <Cmd>XTabMoveBufferPrev<CR>
  nmap <C-S-F3> <Cmd>XTabMoveBufferNext<CR>
  nmap <S-PageUp>   <Cmd>XTabMoveBufferPrev<CR>
  nmap <S-PageDown> <Cmd>XTabMoveBufferNext<CR>
  nmap <BS> <Plug>(XT-Select-Buffer)

  nmap <Leader>1 1<Plug>(XT-Select-Buffer)
  nmap <Leader>2 2<Plug>(XT-Select-Buffer)
  nmap <Leader>3 3<Plug>(XT-Select-Buffer)
  nmap <Leader>4 4<Plug>(XT-Select-Buffer)
  nmap <Leader>5 5<Plug>(XT-Select-Buffer)
  nmap <Leader>6 6<Plug>(XT-Select-Buffer)
  nmap <Leader>7 7<Plug>(XT-Select-Buffer)
  nmap <Leader>8 8<Plug>(XT-Select-Buffer)
  nmap <Leader>9 9<Plug>(XT-Select-Buffer)
  nmap <Leader>0 0<Plug>(XT-Select-Buffer)

  function! s:xtabline_ignore_buffer() abort
    if &ft ==? 'scrollbar'
      " setlocal buftype=
    endif
  endfunction

  function! s:xtabline_reformat() abort
    if winwidth(0) > 150
      let g:xtabline_settings.show_right_corner = 1
    else
      let g:xtabline_settings.show_right_corner = 0
    endif
  endfunction
  call s:xtabline_reformat()
  augroup vimrc_xtabline
    autocmd!
    autocmd VimResized * call s:xtabline_reformat() | call xtabline#cmds#run("reset_buffer")
    " autocmd BufNew * call s:xtabline_ignore_buffer()
  augroup END
endif

"-------------------------------
" vim-gutentags
if IsPluginInstalled('vim-gutentags')
  let g:gutentags_enabled = 0
  let g:gutentags_add_default_project_roots = 0
  let g:gutentags_project_root  = ['package.json', '.git', '.hg', '.svn']
  let g:gutentags_exclude_filetypes = ['gitcommit', 'gitconfig', 'gitrebase', 'gitsendemail', 'git']
  let g:gutentags_generate_on_new = 1
  let g:gutentags_generate_on_missing = 1
  let g:gutentags_generate_on_write = 1
  let g:gutentags_generate_on_empty_buffer = 0
  let g:gutentags_ctags_extra_args = ['--tag-relative=yes', '--fields=+ailmnS']
  let g:gutentags_ctags_exclude = [
        \  '*.git', '*.svn', '*.hg',
        \  'cache', 'build', 'dist', 'bin', 'node_modules', 'bower_components',
        \  '*-lock.json',  '*.lock',
        \  '*.min.*',
        \  '*.bak',
        \  '*.zip',
        \  '*.pyc',
        \  '*.class',
        \  '*.sln',
        \  '*.csproj', '*.csproj.user',
        \  '*.tmp',
        \  '*.cache',
        \  '*.vscode',
        \  '*.pdb',
        \  '*.exe', '*.dll', '*.bin',
        \  '*.mp3', '*.ogg', '*.flac',
        \  '*.swp', '*.swo',
        \  '.DS_Store', '*.plist',
        \  '*.bmp', '*.gif', '*.ico', '*.jpg', '*.png', '*.svg',
        \  '*.rar', '*.zip', '*.tar', '*.tar.gz', '*.tar.xz', '*.tar.bz2',
        \  '*.pdf', '*.doc', '*.docx', '*.ppt', '*.pptx', '*.xls',
        \]

  let g:gutentags_enabled = 1
  let g:gutentags_modules = []
  if executable('ctags')
    let g:gutentags_modules += ['ctags']
  endif
  if executable('cscope')
    let g:gutentags_modules += ['cscope']
  endif
  if executable('gtags-cscope') && executable('gtags')
    let g:gutentags_modules += ['gtags_cscope']
  endif
  let g:gutentags_cache_dir = expand('~/.cache/tags')
  if !isdirectory(g:gutentags_cache_dir)
    call mkdir(g:gutentags_cache_dir, 'p')
  endif
  let g:gutentags_gtags_dbpath = g:gutentags_cache_dir
  let g:gutentags_define_advanced_commands = 1

  function! s:SetupCPPTags()
    let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extra=+q']
    let g:gutentags_ctags_extra_args += ['--c++-kinds=+px']
    let g:gutentags_ctags_extra_args += ['--c-kinds=+px']
    let g:gutentags_ctags_extra_args += ['/usr/include', '/usr/local/include']
  endfunction

  " lazy load for vim-plug
  " command! GutentagsSetup call gutentags#setup_gutentags()
  augroup vimrc_gutentags
    autocmd!
    " autocmd! User vim-gutentags call gutentags#setup_gutentags()
    autocmd! FileType c,cpp call <SID>SetupCPPTags()
  augroup END
endif

"-------------------------------
" gutentags_plus
if IsPluginInstalled('gutentags_plus')
  let g:gutentags_plus_nomap = 1
endif


"-------------------------------
" yankround
if IsPluginInstalled('yankround.vim')
  nmap p <Plug>(yankround-p)
  xmap p <Plug>(yankround-p)
  nmap P <Plug>(yankround-P)
  nmap gp <Plug>(yankround-gp)
  xmap gp <Plug>(yankround-gp)
  nmap gP <Plug>(yankround-gP)
  nmap <C-p> <Plug>(yankround-prev)
  nmap <C-n> <Plug>(yankround-next)
  let g:yankround_max_history = 100
  let g:yankround_dir = '~/.cache/yankround'
  nnoremap g<C-p> <Cmd>CtrlPYankRound<CR>
  "nnoremap <SID>(ctrlp) <Cmd>CtrlP<CR>
  "nmap <expr><C-p> yankround#is_active() ? "\<Plug>(yankround-prev)" : "<SID>(ctrlp)"
endif

"-------------------------------
" cscope
if has('cscope')
  set nocst
  set csto=0
  set csre
  set nocsverb
  " add any database in current directory
  if filereadable('cscope.out')
    cs add cscope.out
    " else add database pointed to by environment
  elseif $CSCOPE_DB !=? ''
    cs add $CSCOPE_DB
  endif
  set csverb
  " To open quickfix annoying
  " set cscopequickfix=s-,c-,d-,i-,t-,e-
  nnoremap <cscope> <Nop>
  nmap [SubLeader]c <cscope>
  nmap <cscope>s <Cmd>cs find s <C-R>=expand("<cword>")<CR><CR>
  nmap <cscope>g <Cmd>cs find g <C-R>=expand("<cword>")<CR><CR>
  nmap <cscope>c <Cmd>cs find c <C-R>=expand("<cword>")<CR><CR>
  nmap <cscope>t <Cmd>cs find t <C-R>=expand("<cword>")<CR><CR>
  nmap <cscope>e <Cmd>cs find e <C-R>=expand("<cword>")<CR><CR>
  nmap <cscope>f <Cmd>cs find f <C-R>=expand("<cfile>")<CR><CR>
  nmap <cscope>i <Cmd>cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
  nmap <cscope>d <Cmd>cs find d <C-R>=expand("<cword>")<CR><CR>
endif


"-------------------------------
" nvim-scrollview
if s:plug.is_installed('nvim-scrollview')
  highlight ScrollView ctermbg=159 guibg=LightCyan
endif

if s:coc_plugin_is_installed('coc-fzf-preview')
  function! s:buffers_delete_from_lines(lines) abort
    for line in a:lines
      let matches = matchlist(line, '\[\(\d\+\)\]')
      if len(matches) >= 1
        execute 'Bdelete! ' . matches[1]
      endif
    endfor
  endfunction

  let g:fzf_preview_git_files_command   = 'git ls-files --exclude-standard | while read line; do if [[ ! -L $line ]] && [[ -f $line ]]; then echo $line; fi; done'
  let g:fzf_preview_filelist_command = 'rg --files --hidden --no-messages -g \!"* *" -g \!".git"'
  let g:fzf_preview_dev_icons_limit = 5000
  let g:fzf_preview_cache_directory = expand('~/.cache/nvim/fzf_preview')
  let $BAT_THEME = 'gruvbox'
  let $BAT_STYLE = 'grid,header'
  let $FZF_PREVIEW_PREVIEW_BAT_THEME = 'gruvbox'
  let $FZF_DEFAULT_OPTS = '--color=bg+:#1d2021,bg:#1d2021,spinner:#d8a657,hl:#a9b665,fg:#d4be98,header:#928374,info:#89b482,pointer:#7daea3,marker:#d8a657,fg+:#d4be98,prompt:#e78a4e,hl+:#89b482'
  let g:fzf_preview_default_fzf_options = {
        \ '--reverse': v:true,
        \ '--preview-window': 'wrap',
        \ '--exact': v:true,
        \ '--no-sort': v:true,
        \ }

  if s:plug.is_installed('vim-devicons')
    let g:fzf_preview_use_dev_icons = 1
  endif
  let g:fzf_preview_quit_map = 1

  function! s:fzf_preview_settings() abort
    let g:fzf_preview_command = 'bat --color=always --style=grid,header {-1}'
    let g:fzf_preview_custom_processes['open-file'] = fzf_preview#remote#process#get_default_processes('open-file', 'coc')
    let g:fzf_preview_custom_processes['open-file']['ctrl-s'] = g:fzf_preview_custom_processes['open-file']['ctrl-x']
    call remove(g:fzf_preview_custom_processes['open-file'], 'ctrl-x')

    let g:fzf_preview_custom_processes['open-buffer'] = fzf_preview#remote#process#get_default_processes('open-buffer', 'coc')
    let g:fzf_preview_custom_processes['open-buffer']['ctrl-s'] = g:fzf_preview_custom_processes['open-buffer']['ctrl-x']
    call remove(g:fzf_preview_custom_processes['open-buffer'], 'ctrl-q')
    let g:fzf_preview_custom_processes['open-buffer']['ctrl-x'] = get(function('s:buffers_delete_from_lines'), 'name')

    let g:fzf_preview_custom_processes['open-bufnr'] = fzf_preview#remote#process#get_default_processes('open-bufnr', 'coc')
    let g:fzf_preview_custom_processes['open-bufnr']['ctrl-s'] = g:fzf_preview_custom_processes['open-bufnr']['ctrl-x']
    call remove(g:fzf_preview_custom_processes['open-bufnr'], 'ctrl-q')
    let g:fzf_preview_custom_processes['open-bufnr']['ctrl-x'] = get(function('s:buffers_delete_from_lines'), 'name')
    " let g:fzf_preview_default_fzf_options = { '--reverse': v:true }
  endfunction

  augroup vimrc_fzf_preview
    autocmd!
    autocmd User fzf_preview#coc#initialized call s:fzf_preview_settings()
  augroup END

  " conflict coc-fzf
  " let g:fzf_layout = {
  "       \ 'window': 'call fzf_preview#window#create_centered_floating_window()',
  "       \ }

  " Map
  nnoremap [fuzzy-finder]   <Nop>
  vnoremap [fuzzy-finder]   <Nop>
  nmap    z [fuzzy-finder]
  vmap    z [fuzzy-finder]

  xnoremap <CR>         "sy:CocCommand fzf-preview.ProjectGrep<Space>-F<Space><C-r>=substitute(substitute(@s, '\n', '', 'g'), '/', '\\/', 'g')<CR>
  nnoremap <Leader><Leader> <Cmd>CocCommand fzf-preview.FromResources project_mru git --add-fzf-arg=--keep-right<CR>
  nnoremap <Leader>p    <Cmd>CocCommand fzf-preview.FromResources project_mru git --add-fzf-arg=--keep-right<CR>
  nnoremap <Leader>.    <Cmd>CocCommand fzf-preview.ProjectFiles --add-fzf-arg=--keep-right<CR>
  nnoremap <Leader>;    <Cmd>CocCommand fzf-preview.MruFiles --add-fzf-arg=--keep-right<CR>
  nnoremap <Leader>'    <Cmd>CocCommand fzf-preview.MrwFiles --add-fzf-arg=--keep-right<CR>
  nnoremap <Leader>,            :<C-u>CocCommand fzf-preview.ProjectGrep<Space>
  nnoremap [fuzzy-finder][fuzzy-finder] <Cmd>CocCommand fzf-preview.FromResources project_mru git --add-fzf-arg=--keep-right<CR>
  nnoremap [fuzzy-finder]p     <Cmd>CocCommand fzf-preview.FromResources project_mru git --add-fzf-arg=--keep-right<CR>
  nnoremap [fuzzy-finder].     <Cmd>CocCommand fzf-preview.ProjectFiles --add-fzf-arg=--keep-right<CR>
  nnoremap [fuzzy-finder];     <Cmd>CocCommand fzf-preview.MruFiles --add-fzf-arg=--keep-right<CR>
  nnoremap [fuzzy-finder]'     <Cmd>CocCommand fzf-preview.MrwFiles --add-fzf-arg=--keep-right<CR>
  vnoremap [fuzzy-finder],     y:CocCommand fzf-preview.ProjectGrep<Space>"<C-r>=escape(@", '\\.*$^[]')<CR>"
  nnoremap [fuzzy-finder],     :<C-u>CocCommand fzf-preview.ProjectGrep<Space>
  nnoremap [fuzzy-finder]g     <Cmd>CocCommand fzf-preview.GitStatus --add-fzf-arg=--keep-right<CR>
  nnoremap [fuzzy-finder]<C-g> <Cmd>CocCommand fzf-preview.GitActions --add-fzf-arg=--keep-right<CR>
  nnoremap <Leader>g     <Cmd>CocCommand fzf-preview.GitStatus --add-fzf-arg=--keep-right<CR>
  nnoremap <Leader><C-g> <Cmd>CocCommand fzf-preview.GitActions --add-fzf-arg=--keep-right<CR>
  "nnoremap [fuzzy-finder]b     <Cmd>CocCommand fzf-preview.Buffers<CR>
  nnoremap [fuzzy-finder]b     <Cmd>CocCommand fzf-preview.Buffers --add-fzf-arg=--keep-right<CR>
  nnoremap [fuzzy-finder]a     <Cmd>CocCommand fzf-preview.AllBuffers --add-fzf-arg=--keep-right<CR>
  nnoremap [fuzzy-finder]m     <Cmd>CocCommand fzf-preview.Marks<CR>
  nnoremap <Leader>*    <Cmd>CocCommand fzf-preview.Lines --resume --add-fzf-arg=--no-sort --add-fzf-arg=--query="'<C-r>=expand('<cword>')<CR>"<CR>
  nnoremap <Leader>/    <Cmd>CocCommand fzf-preview.Lines --resume --add-fzf-arg=--no-sort --add-fzf-arg=--query="'" --resume<CR>
  nnoremap <Leader>#    :<C-u>CocCommand fzf-preview.ProjectGrep<Space>"<C-r>=expand('<cword>')<CR>"
  nnoremap [fuzzy-finder]*     <Cmd>CocCommand fzf-preview.Lines --resume --add-fzf-arg=--no-sort --add-fzf-arg=--query="'<C-r>=expand('<cword>')<CR>"<CR>
  nnoremap [fuzzy-finder]/     <Cmd>CocCommand fzf-preview.Lines --resume --add-fzf-arg=--no-sort --add-fzf-arg=--query="'"<CR>
  nnoremap [fuzzy-finder]**    :<C-u>CocCommand fzf-preview.ProjectGrep<Space>"<C-r>=expand('<cword>')<CR>"
  nnoremap [fuzzy-finder]<C-o> <Cmd>CocCommand fzf-preview.Jumps<CR>
  nnoremap [fuzzy-finder]j     <Cmd>CocCommand fzf-preview.Jumps<CR>
  nnoremap [fuzzy-finder]c     <Cmd>CocCommand fzf-preview.Changes<CR>
  nnoremap [fuzzy-finder]t     <Cmd>CocCommand fzf-preview.Ctags<CR>
  nnoremap [fuzzy-finder]tb    <Cmd>CocCommand fzf-preview.BufferTags --resume<CR>
  nnoremap [fuzzy-finder]q     <Cmd>CocCommand fzf-preview.QuickFix<CR>
  nnoremap [fuzzy-finder]l     <Cmd>CocCommand fzf-preview.LocationList<CR>
  nnoremap <Leader>gf   <Cmd>CocCommand fzf-preview.FromResources project_mru git --add-fzf-arg=--select-1 --add-fzf-arg=--query="<C-r>=substitute(expand('<cfile>'), '^\.\+/', '', '')<CR>"<CR>

  nnoremap [fuzzy-finder]v     <Cmd>CocCommand fzf-preview.VistaCtags<CR>
  nnoremap [fuzzy-finder]vb    <Cmd>CocCommand fzf-preview.VistaBufferCtags<CR>
  nnoremap [fuzzy-finder]r     <Cmd>CocCommand fzf-preview.CocReferences<CR>
  nnoremap [fuzzy-finder]d     <Cmd>CocCommand fzf-preview.CocDiagnostics<CR>
  nnoremap [fuzzy-finder]c     <Cmd>CocCommand fzf-preview.CocCurrentDiagnostics<CR>
  nnoremap [fuzzy-finder]n     <Cmd>CocCommand fzf-preview.Lines --add-fzf-arg=--no-sort --add-fzf-arg=--query="'<C-r>=substitute(@/, '\(^\\v\)\\|\\\(<\\|>\)', '', 'g')<CR>"<CR>
  nnoremap [fuzzy-finder]h     <Cmd>CocCommand fzf-preview.CommandPalette<CR>

  " resume
  nnoremap [fuzzy-finder-resume]   <Nop>
  vnoremap [fuzzy-finder-resume]   <Nop>
  nmap    Z [fuzzy-finder-resume]
  vmap    Z [fuzzy-finder-resume]
  nnoremap <Leader>P    <Cmd>CocCommand fzf-preview.FromResources project_mru git --add-fzf-arg=--keep-right --resume<CR>
  nnoremap <Leader>>    <Cmd>CocCommand fzf-preview.ProjectFiles --add-fzf-arg=--keep-right --resume<CR>
  nnoremap <Leader>:    <Cmd>CocCommand fzf-preview.MruFiles --add-fzf-arg=--keep-right --resume<CR>
  nnoremap <Leader>"    <Cmd>CocCommand fzf-preview.MrwFiles --add-fzf-arg=--keep-right --resume<CR>
  nnoremap <Leader>,    :<C-u>CocCommand fzf-preview.ProjectGrep<Space>
  nnoremap [fuzzy-finder-resume][fuzzy-finder-resume] <Cmd>CocCommand fzf-preview.FromResources project_mru git --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume]p     <Cmd>CocCommand fzf-preview.FromResources project_mru git --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume].     <Cmd>CocCommand fzf-preview.ProjectFiles --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume];     <Cmd>CocCommand fzf-preview.MruFiles --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume]'     <Cmd>CocCommand fzf-preview.MrwFiles --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume],     :<C-u>CocCommand fzf-preview.ProjectGrep<Space>
  vnoremap [fuzzy-finder-resume].     y:CocCommand fzf-preview.ProjectGrep<Space>"<C-r>=escape(@", '\\.*$^[]') --resume<CR>"
  nnoremap [fuzzy-finder-resume]g     <Cmd>CocCommand fzf-preview.GitStatus --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume]b     <Cmd>CocCommand fzf-preview.Buffers --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume]a     <Cmd>CocCommand fzf-preview.AllBuffers --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume]m     <Cmd>CocCommand fzf-preview.Marks --resume<CR>
  nnoremap [fuzzy-finder-resume]w     <Cmd>CocCommand fzf-preview.MrwFiles --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume]g     <Cmd>CocCommand fzf-preview.GitStatus --add-fzf-arg=--keep-right --resume<CR>
  nnoremap [fuzzy-finder-resume]j     <Cmd>CocCommand fzf-preview.Jumps --resume<CR>
  nnoremap [fuzzy-finder-resume]c     <Cmd>CocCommand fzf-preview.Changes --resume<CR>
  nnoremap [fuzzy-finder-resume]t     <Cmd>CocCommand fzf-preview.Ctags --resume<CR>
  nnoremap [fuzzy-finder-resume]tb    <Cmd>CocCommand fzf-preview.BufferTags --resume --resume<CR>
  nnoremap [fuzzy-finder-resume]q     <Cmd>CocCommand fzf-preview.QuickFix --resume<CR>
  nnoremap [fuzzy-finder-resume]l     <Cmd>CocCommand fzf-preview.LocationList --resume<CR>
  nnoremap [fuzzy-finder-resume]n     <Cmd>CocCommand fzf-preview.Lines --add-fzf-arg=--no-sort --add-fzf-arg=--query="'<C-r>=substitute(@/, '\(^\\v\)\\|\\\(<\\|>\)', '', 'g')<CR>"<CR>

  " Command
  command! -bang FZFTodo FzfPreviewProjectGrep FIXME\|TODO<CR>
endif
"-------------------------------
" auto-pairs
if s:plug.is_installed('auto-pairs')
  let g:AutoPairsShortcutToggle = ''
  " let g:AutoPairsOnlyAtEOL = 1
  let g:AutoPairsOnlyBeforeClose = 1
  command! AutoPairsToggle call AutoPairsToggle()
endif

"-------------------------------
" accelerated-jk
if s:plug.is_installed('accelerated-jk')
  let g:accelerated_jk_acceleration_table = [30,60,80,85,90,95,100]
  nmap <expr> j v:count ? '<Plug>(accelerated_jk_j)' : '<Plug>(accelerated_jk_gj)'
  nmap <expr> k v:count ? '<Plug>(accelerated_jk_k)' : '<Plug>(accelerated_jk_gk)'
endif

"-------------------------------
" vim-buffergator
if s:plug.is_installed('vim-buffergator')
  let g:buffergator_viewport_split_policy = 'T'
  let g:buffergator_hsplit_size = 10
  let g:buffergator_suppress_keymaps = 1
  nmap <S-F12> <Cmd>BuffergatorToggle<CR>
  " nmap <S-F9> :<CR>
  " nmap <C-F9> :<CR>
  " nmap <C-S-F9> :<CR>
endif

"-------------------------------
" vim-session
if s:plug.is_installed('vim-session')
  function! s:session_config(dir) abort
    " session保存ディレクトリをそのディレクトリの設定
    let g:session_directory = a:dir
    " vimを辞める時に自動保存
    " let g:session_autosave = 'yes'
    " 引数なしでvimを起動した時にsession保存ディレクトリのdefault.vimを開く
    "let g:session_autoload = 'yes'
    " 1分間に1回自動保存
    " let g:session_autosave_periodic = 1
    let g:session_autosave = 'no'
    let g:session_autoload = 'no'
  endfunction
  " 現在のディレクトリ直下の .vimsessions/ を取得
  " let s:local_session_directory = xolox#misc#path#merge(getcwd(), '.vim/sessions')
  let s:global_session_directory = expand('~/.local/share/nvim/sessions')
  call mkdir(s:global_session_directory, 'p')

  if isdirectory(s:local_session_directory)
    call s:session_config(s:local_session_directory)
  elseif isdirectory(s:global_session_directory)
    call s:session_config(s:global_session_directory)
  else
    let g:session_autosave = 'no'
    let g:session_autoload = 'no'
  endif
  unlet s:local_session_directory
  unlet s:global_session_directory
endif

"-------------------------------
" tagbar
if s:plug.is_installed('tagbar')
  " highlight link TagbarHighlight PmenuSel
  let g:tagbar_type_markdown = {
        \ 'ctagstype': 'markdown',
        \ 'ctagsbin' : 'markdown2ctags',
        \ 'ctagsargs' : '-f - --sort=yes',
        \ 'kinds' : [
        \ 's:sections',
        \ 'i:images'
        \ ],
        \ 'sro' : '|',
        \ 'kind2scope' : {
        \ 's' : 'section',
        \ },
        \ 'sort': 0,
        \ }
endif

"-------------------------------
" fzf-mru.vim
if s:plug.is_installed('fzf-mru.vim')
  let g:fzf_mru_relative = 0
  nnoremap <Leader>; <Cmd>FZFMru<CR>
endif

"-------------------------------
" fzf-filemru
if s:plug.is_installed('fzf-filemru')
  augroup vimrc_fzf_filemru
    autocmd!
    autocmd BufEnter * UpdateMru
  augroup END
  let g:fzf_filemru_git_ls = 1
  function! s:fzf_file_mru_without_find(args) abort
    let l:fzf_default_tmp = $FZF_DEFAULT_COMMAND
    let $FZF_DEFAULT_COMMAND = ':'
    execute a:args
    let $FZF_DEFAULT_COMMAND = l:fzf_default_tmp
  endfunction
  command! -nargs=* FZFFileMru FilesMru
  command! -nargs=* FZFProjectMru call s:fzf_file_mru_without_find('ProjectMru')
  command! -nargs=* -bang FZFUpdateMru call s:fzf_file_mru_without_find('UpdateMru')
  nnoremap <Leader>. <Cmd>FZFFileMru<CR>
  nnoremap <Leader>p <Cmd>FZFProjectMru<CR>
endif

"-------------------------------
" defx.nvim
if s:plug.is_installed('defx.nvim')
  function! s:defx_my_settings() abort
    " Define mappings
    nnoremap <silent><buffer><expr> <CR>
          \ defx#do_action('drop')
    nnoremap <silent><buffer><expr> c
          \ defx#do_action('copy')
    nnoremap <silent><buffer><expr> m
          \ defx#do_action('move')
    nnoremap <silent><buffer><expr> p
          \ defx#do_action('paste')
    nnoremap <silent><buffer><expr> l
          \ defx#do_action('open_directory')
    nnoremap <silent><buffer><expr> E
          \ defx#do_action('open', 'vsplit')
    nnoremap <silent><buffer><expr> P
          \ defx#do_action('open', 'pedit')
    nnoremap <silent><buffer><expr> o
          \ defx#do_action('open_or_close_tree')
    nnoremap <silent><buffer><expr> K
          \ defx#do_action('new_directory')
    nnoremap <silent><buffer><expr> N
          \ defx#do_action('new_file')
    nnoremap <silent><buffer><expr> M
          \ defx#do_action('new_multiple_files')
    nnoremap <silent><buffer><expr> C
          \ defx#do_action('toggle_columns',
          \                'mark:indent:icon:filename:type:size:time')
    nnoremap <silent><buffer><expr> S
          \ defx#do_action('toggle_sort', 'time')
    nnoremap <silent><buffer><expr> d
          \ defx#do_action('remove')
    nnoremap <silent><buffer><expr> r
          \ defx#do_action('rename')
    nnoremap <silent><buffer><expr> !
          \ defx#do_action('execute_command')
    nnoremap <silent><buffer><expr> x
          \ defx#do_action('execute_system')
    nnoremap <silent><buffer><expr> yy
          \ defx#do_action('yank_path')
    nnoremap <silent><buffer><expr> .
          \ defx#do_action('toggle_ignored_files')
    nnoremap <silent><buffer><expr> ;
          \ defx#do_action('repeat')
    nnoremap <silent><buffer><expr> h
          \ defx#do_action('cd', ['..'])
    nnoremap <silent><buffer><expr> ~
          \ defx#do_action('cd')
    nnoremap <silent><buffer><expr> q
          \ defx#do_action('quit')
    nnoremap <silent><buffer><expr> <Esc>
          \ defx#do_action('quit')
    nnoremap <silent><buffer><expr> <Space>
          \ defx#do_action('toggle_select') . 'j'
    nnoremap <silent><buffer><expr> *
          \ defx#do_action('toggle_select_all')
    nnoremap <silent><buffer><expr> j
          \ line('.') == line('$') ? 'gg' : 'j'
    nnoremap <silent><buffer><expr> k
          \ line('.') == 1 ? 'G' : 'k'
    nnoremap <silent><buffer><expr> <C-l>
          \ defx#do_action('redraw')
    nnoremap <silent><buffer><expr> <C-g>
          \ defx#do_action('print')
    nnoremap <silent><buffer><expr> cd
          \ defx#do_action('change_vim_cwd')
  endfunction
  command! DefxProject Defx -split=vertical -winwidth=30 -direction=topleft -toggle -resume
  nnoremap <F12> <Cmd>Vista!!<CR>:DefxProject<CR>

  augroup vimrc_defx
    autocmd!
    autocmd FileType defx call s:defx_my_settings()
    autocmd VimEnter * sil! au! FileExplorer *
    autocmd BufEnter * if vimrc#is_dir(expand('%')) | bd | exe 'Defx' | endif
  augroup END
endif

"-------------------------------
" fila.vim
if s:plug.is_installed('fila.vim')
  nnoremap <F12> <Cmd>Vista!!<CR>:Fila -drawer<CR>
endif
"-------------------------------
" vim-dispatch
if s:plug.is_installed('vim-dispatch')
  nnoremap <Leader>R <Cmd>Copen<Bar>Dispatch<CR>
  " nnoremap [SubLeader]q   <Cmd>Copen<CR>
  nnoremap [make]<CR> <Cmd>Make
endif
"-------------------------------
" vim-dirvish
if s:plug.is_installed('vim-dirvish')
  let g:dirvish_mode = ':sort r /[^\/]$/'
endif
"-------------------------------
" vim-buftabline
if s:plug.is_installed('vim-buftabline')
  let g:buftabline_show = 1
  let g:buftabline_numbers = 2
  let g:buftabline_indicators = 1
  nmap <Leader>1 <Plug>BufTabLine.Go(1)
  nmap <Leader>2 <Plug>BufTabLine.Go(2)
  nmap <Leader>3 <Plug>BufTabLine.Go(3)
  nmap <Leader>4 <Plug>BufTabLine.Go(4)
  nmap <Leader>5 <Plug>BufTabLine.Go(5)
  nmap <Leader>6 <Plug>BufTabLine.Go(6)
  nmap <Leader>7 <Plug>BufTabLine.Go(7)
  nmap <Leader>8 <Plug>BufTabLine.Go(8)
  nmap <Leader>9 <Plug>BufTabLine.Go(9)
  nmap <Leader>0 <Plug>BufTabLine.Go(10)
endif
"-------------------------------
" vim-anzu
if s:plug.is_installed('vim-anzu')
  " mapping
  nmap n <Plug>(anzu-n-with-echo)
  nmap N <Plug>(anzu-N-with-echo)
  nmap g* <Plug>(anzu-star-with-echo)n
  nmap g# <Plug>(anzu-sharp-with-echo)N
  " clear status
  "nmap <Esc><Esc> <Plug>(anzu-clear-search-status)
  " statusline
  if exists('anzu#search_status')
    set statusline=%{anzu#search_status()}
  endif
  " if start anzu-mode key mapping
  " anzu-mode is anzu(12/51) in screen
  " nmap n <Plug>(anzu-mode-n)
  " nmap N <Plug>(anzu-mode-N)
  let g:anzu_bottomtop_word = 'search hit BOTTOM, continuing at TOP'
  let g:anzu_topbottom_word = 'search hit TOP, continuing at BOTTOM'
  let g:anzu_status_format = '%p(%i/%l) %#WarningMsg#%w'
endif
"-------------------------------
" hybrid
if s:plug.is_installed('vim-hybrid')
  let s:lightline_colorscheme = 'wombat'
  set background=dark
  colorscheme hybrid
endif
 fzf.vim
 else

   function! FzfOmniFiles()
     let is_git = system('git status')
     if v:shell_error
       :FZFFiles
     else
       :FZFGFiles
     endif
   endfunction
   nnoremap <Leader>p <Cmd>call FzfOmniFiles()<CR>
   nnoremap <Leader>f; <Cmd>FZF<CR>
   nnoremap <Leader>. <Cmd>FZF<CR>
   nnoremap <Leader>ag <Cmd>FZFAg <C-R>=expand("<cword>")<CR><CR>
   nnoremap <Leader>rg <Cmd>FZFRg <C-R>=expand("<cword>")<CR><CR>
   nnoremap <Leader>fb <Cmd>FZFBuffers<CR>
   nnoremap <Leader>fc <Cmd>FZFCommands<CR>

   command! FZFOmniFiles call FzfOmniFiles()
   command! FZFMruSimple call fzf#run({
         \ 'source':  reverse(s:all_files()),
         \ 'sink':    'edit',
         \ 'options': '-m -x +s',
         \ 'down':    '40%' })

   function! s:all_files() abort
     return extend(
           \ filter(copy(v:oldfiles),
           \        "v:val !~ 'fugitive:\\|NERD_tree\\|^/tmp/\\|.git/'"),
           \ map(filter(range(1, bufnr('$')), 'buflisted(v:val)'), 'bufname(v:val)'))
   endfunction
   nnoremap <Leader>; <Cmd>FZFMruSimple<CR>
   command! -bang -nargs=* GGrep
         \ call fzf#vim#grep(
         \   'git grep --line-number '.shellescape(<q-args>), 0,
         \   fzf#vim#with_preview({ 'dir': systemlist('git rev-parse --show-toplevel')[0]  }), <bang>0 )

   command! -bang -nargs=* FZFGrep
         \  call fzf#vim#grep('grep --line-number --ignore-case --recursive --exclude=".git/*" --color="always" '.shellescape(<q-args>), 0, <bang>0)
   function! s:fzf_unite_grep(args) abort
     if executable('rg')
       execute 'FZFRg ' . a:args
     elseif executable('ag')
       execute 'FZFAg ' . a:args
     else
       execute 'FZFGrep ' . a:args
     endif
   endfunction
   nmap <Leader>, <Cmd>FZFSearch<Space>
   command! -bang -nargs=* FZFSearch call s:fzf_unite_grep(<q-args>)
   command! -bang FZFTodo FZFSearch FIXME|TODO<CR>

   let $FZF_DEFAULT_OPTS = '--bind ctrl-a:select-all --preview
         \ "
         \ if [[ $(file --mime {}) =~ /directory ]]; then
         \   echo {} is a directory;
         \ elif [[ $(file --mime {}) =~ binary ]]; then
         \   echo {} is a binary file;
         \ elif [[ {} == *:* ]]; then
         \   f=$(echo {} | cut -d : -f 1); n=$(echo {} | cut -d : -f 2) &&
         \    ((bat --color=always --style=grid $f ||
         \      highlight -O ansi -l $f ||
         \      coderay $f ||
         \      rougify $f ||
         \     tail +$n $f) 2> /dev/null | tail +$n | head -500);
         \ elif [[ -e $(echo {} | cut -d \" \" -f 2 2> /dev/null) ]]; then
         \   f=$(echo {} | cut -d \" \" -f 2);
         \    ((bat --color=always --style=grid $f ||
         \      highlight -O ansi -l $f ||
         \      coderay $f ||
         \      rougify $f) 2> /dev/null | head -500);
         \ elif [[ ! -e {} ]]; then
         \   :
         \ else
         \   (bat --color=always {} ||
         \    highlight -O ansi -l {} ||
         \    coderay {} ||
         \    rougify {} ||
         \    cat {} | head -500) 2> /dev/null;
         \ fi
         \ "
         \ --bind "?:toggle-preview"
         \ --preview-window hidden:wrap
         \ '

   " floating fzf
   if has('nvim')
     let $FZF_DEFAULT_OPTS .= '--border --margin=0,2 --layout=reverse'
     function! FloatingFZF()
       let width = float2nr(&columns * 0.9)
       let height = float2nr(&lines * 0.6)
       let opts = {
             \ 'relative': 'editor',
             \ 'row': (&lines - height) / 2,
             \ 'col': (&columns - width) / 2,
             \ 'width': width,
             \ 'height': height,
             \ 'style': 'minimal'
             \ }

       let win = nvim_open_win(nvim_create_buf(v:false, v:true), v:true, opts)
       call setwinvar(win, '&winhighlight', 'NormalFloat:Normal')
     endfunction

     let g:fzf_layout = { 'window': 'call FloatingFZF()' }
   endif
"-------------------------------
" vim-hybrid
if s:plug.is_installed('vim-hybrid')
  let g:hybrid_custom_term_colors = 1
  let g:hybrid_reduced_contrast = 1
  set background=dark
  colorscheme hybrid
  highlight! VertSplit ctermfg=236 ctermbg=236 guibg=#2c2c2c guifg=#2c2c2c
  " highlight! WarningMsg term=reverse cterm=reverse
  highlight! SpellBad cterm=underline ctermfg=247 ctermbg=NONE gui=underline guifg=#9e9e9e
  highlight! SpecialKey cterm=underline ctermfg=NONE ctermbg=NONE gui=underline guifg=NONE
  " iceberg
  " highlight! Todo ctermbg=234 ctermfg=150 guibg=#45493e guifg=#b4be82
  " highlight! Todo ctermbg=NONE ctermfg=150 guibg=NONE guifg=#b4be82
  " solarized dark
  " highlight! Todo ctermbg=NONE ctermfg=125 guibg=NONE guifg=#d33682
  " onedark
  " highlight! Todo ctermbg=NONE ctermfg=170 guibg=NONE guifg=#C678DD cterm=bold
  " papercolor
  " highlight! Todo ctermbg=NONE ctermfg=35 guibg=NONE guifg=#00af5f cterm=bold
  " gotham
  " highlight! Todo ctermbg=NONE ctermfg=67 guibg=NONE guifg=#888ca6 cterm=bold
  highlight! Todo ctermbg=NONE ctermfg=13 guibg=NONE guifg=#888ca6 cterm=bold
  " Alduin
  " highlight Todo guifg=#af5f00 guibg=NONE gui=reverse ctermfg=130 ctermbg=NONE cterm=reverse
  " space-vim-dark
  " highlight! Todo ctermbg=NONE ctermfg=172 guibg=NONE guifg=#C678DD cterm=bold
  " molokai
  " highlight! Todo ctermbg=NONE ctermfg=231 cterm=bold guifg=#FFFFFF guibg=NONE gui=bold
  highlight! clear CursorLineNr
  highlight CursorLineNr ctermfg=8 cterm=bold guifg=#8F8F8F
  highlight GitGutterAdd      ctermfg=65 ctermbg=NONE guifg=#5F875F guibg=NONE
  highlight GitGutterChange   ctermfg=60 ctermbg=NONE guifg=#5F5F87 guibg=NONE
  highlight GitGutterDelete   ctermfg=9  ctermbg=NONE guifg=#cc6666 guibg=NONE
  highlight TabLineSel ctermbg=252 ctermfg=235 guibg=#d0d0d0 guifg=#242424
  highlight PmenuSel ctermbg=236 ctermfg=244 guibg=#353535 guibg=#808080
  highlight Tabline ctermbg=248 ctermfg=238 guibg=#a8a8a8 guifg=#444444
  highlight TabLineFill ctermbg=248 ctermfg=238 guibg=#a8a8a8 guifg=#444444
  highlight clear SpellBad
  highlight SpellBad cterm=underline gui=undercurl ctermbg=NONE
        \ ctermfg=NONE guibg=NONE guifg=NONE guisp=NONE
  highlight QuickScopePrimary guifg=#afff5f gui=underline ctermfg=155 cterm=underline
  highlight QuickScopeSecondary guifg=#5fffff gui=underline ctermfg=81 cterm=underline
  highlight! default link CocErrorHighlight WarningMsg
  highlight! default link CocErrorSign CocErrorHighlight
  highlight! CocWarningSign  ctermfg=Brown guifg=#ff922b
  highlight! default link CocInfoSign Title
  highlight! default link CocHintSign Question
  highlight clear SignColumn
  highlight DiffAdd      ctermfg=65 ctermbg=NONE guifg=#5F875F guibg=NONE
  highlight DiffChange   ctermfg=60 ctermbg=NONE guifg=#5F5F87 guibg=NONE
  highlight DiffDelete   ctermfg=9  ctermbg=NONE guifg=#cc6666 guibg=NONE
endif

"-------------------------------
" deoplete-tabnine
if s:plug.is_installed('deoplete-tabnine')
  call deoplete#custom#source('tabnine', 'rank', 50)
  call deoplete#custom#source('tabnine', 'min_pattern_length', 2)
  call deoplete#custom#option('ignore_sources', {'_': ['around', 'buffer', 'tag']})
  " call deoplete#custom#option('ignore_sources', {'_': ['LanguageClient']})
endif

"-------------------------------
" deoplete-rust
if s:plug.is_installed('deoplete-rust')
  let g:deoplete#sources#rust#racer_binary=$HOME . '/.cargo/bin/racer'
  let g:deoplete#sources#rust#rust_source_path= substitute(system("rustup which rustc | xargs dirname"), '\n\+$', '', '')
        \ . '/../lib/rustlib/src/rust/src'
  let g:deoplete#sources#rust#show_duplicates=1
endif

"-------------------------------
" LanguageClient-neovim
if s:plug.is_installed('LanguageClient-neovim')
  " Automatically start language servers.
  let g:LanguageClient_autoStart = 1
  let g:LanguageClient_diagnosticsList = "Location"
  " let g:LanguageClient_diagnosticsList = "Quickfix"
  let g:LanguageClient_useFloatingHover = 1

  let g:LanguageClient_serverCommands = {}
  if executable('rls')
    " rustup component add rls rust-analysis rust-src
    let g:LanguageClient_serverCommands.rust = ['rustup', 'run', 'stable', 'rls']
  endif

  if executable('javascript-typescript-stdio')
    " yarn global add javascript-typescript-langserver   -or-
    " npm i -g javascript-typescript-langserver
    let g:LanguageClient_serverCommands.javascript = ['javascript-typescript-stdio']
    let g:LanguageClient_serverCommands.javascript.jsx = ['tcp://127.0.0.1:2089']
    let g:LanguageClient_serverCommands.typescript = ['javascript-typescript-stdio']
  endif

  if executable('html-languageserver')
    " npm i -g vscode-html-languageserver-bin
    let g:LanguageClient_serverCommands.html = ['html-languageserver', '--stdio']
  endif

  if executable('css-languageserver')
    " yarn global add vscode-css-languageserver-bin   -or-
    " npm i -g vscode-css-languageserver-bin
    let g:LanguageClient_serverCommands.css = ['css-languageserver', '--stdio']
    let g:LanguageClient_serverCommands.less = ['css-languageserver', '--stdio']
  endif

  if executable('cquery')
    " paru -S cquery
    let g:LanguageClient_serverCommands.cpp = ['cquery', '--log-file=/tmp/cq.log', '--init={"cacheDirectory":"/tmp/cquery/"}']
    let g:LanguageClient_serverCommands.c = ['cquery', '--log-file=/tmp/cq.log', '--init={"cacheDirectory":"/tmp/cquery/"}']
  endif

  if executable('pyls')
    " pip install python-language-server
    let g:LanguageClient_serverCommands.python = ['pyls']
  endif

  if executable('go-langserver')
    " go get -u github.com/sourcegraph/go-langserver
    let g:LanguageClient_serverCommands.go = ['go-langserver']
  endif

  let s:lsp_filetypes = join(keys(g:LanguageClient_serverCommands), ",")
  if s:lsp_filetypes != ""
    function! SetLSPShortcuts() abort
      nnoremap <leader>ld :call LanguageClient#textDocument_definition()<CR>
      nnoremap <leader>lr :call LanguageClient#textDocument_rename()<CR>
      nnoremap <leader>lf :call LanguageClient#textDocument_formatting()<CR>
      nnoremap <leader>lt :call LanguageClient#textDocument_typeDefinition()<CR>
      nnoremap <leader>lx :call LanguageClient#textDocument_references()<CR>
      nnoremap <leader>la :call LanguageClient_workspace_applyEdit()<CR>
      nnoremap <leader>lc :call LanguageClient#textDocument_completion()<CR>
      nnoremap <leader>lh :call LanguageClient#textDocument_hover()<CR>
      nnoremap <leader>ls :call LanguageClient_textDocument_documentSymbol()<CR>
      nnoremap <leader>lm :call LanguageClient_contextMenu()<CR>
    endfunction()

    augroup vimrc_lsp
      autocmd!
      execute 'autocmd FileType ' . s:lsp_filetypes . ' call SetLSPShortcuts()'
    augroup END
  endif
endif

"-------------------------------
" nvim-completion-manager
if s:plug.is_installed('nvim-completion-manager')
  " imap <expr> <CR>  (pumvisible() ?  "\<c-y>\<Plug>(expand_or_nl)" : "\<CR>")
  " imap <expr> <Plug>(expand_or_nl) (cm#completed_is_snippet() ? "\<C-U>":"\<CR>")
  " inoremap <c-c> <ESC>
  " inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
  " inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
endif

"-------------------------------
" echodoc.vim
if s:plug.is_installed('echodoc.vim')
  set noshowmode
  let g:echodoc_enable_at_startup = 1
  if has('nvim')
    let g:echodoc#type = 'virtual'
  endif
  set signcolumn=yes
endif

"-------------------------------
" deoplete-clang
if s:plug.is_installed('deoplete-clang')
  let g:deoplete#sources#clang#libclang_path =
        \ substitute(system("ldconfig -p | \grep libclang.so | awk '{print $4}' | head -n 1"),
        \ '\n\+$', '', '')
  if isdirectory('/usr/lib64/clang')
    let g:deoplete#sources#clang#clang_header = '/usr/lib64/clang/'
  else
    let g:deoplete#sources#clang#clang_header = '/usr/lib/clang/'
  endif
endif

"-------------------------------
" deoplete-go
if s:plug.is_installed('deoplete-go')
  let g:deoplete#sources#go#gocode_binary = $GOPATH . '/bin/gocode'
endif

"-------------------------------
" denite.nvim
if s:plug.is_installed('denite.nvim')
  if executable('ag')
    call denite#custom#var('file_rec', 'command',
          \ ['ag', '--follow', '--nocolor', '--nogroup', '-g', ''])

    " call denite#custom#var('grep', 'command', ['ag'])
    " call denite#custom#var('grep', 'recursive_opts', [])
    " call denite#custom#var('grep', 'final_opts', [])
    " call denite#custom#var('grep', 'separator', [])
    " call denite#custom#var('grep', 'default_opts',
    "       \ ['--nocolor', '--nogroup'])
  endif

  nnoremap    [denite]   <Nop>
  nmap    <Leader>u [denite]
  nnoremap [denite]f <Cmd>Denite file_rec<CR>
  nnoremap [denite]g <Cmd>Denite grep<CR>
  nnoremap [denite]l <Cmd>Denite line<CR>
  nnoremap [denite]u <Cmd>Denite file_mru<CR>
  nnoremap [denite]y <Cmd>Denite neoyank<CR>
  nmap <F8> <Cmd>DeniteCursorWord<Space>grep<CR>
  nmap <S-F8> <Cmd>DeniteProjectDir<Space>grep<CR>
endif

"-------------------------------
" deoplete.nvim
if s:plug.is_installed('deoplete.nvim')
  " Use deoplete.
  let g:deoplete#enable_at_startup = 1
  " Use smartcase.
  let g:deoplete#enable_smart_case = 1
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h> deoplete#smart_close_popup()."\<C-h>"
  inoremap <expr><BS>  deoplete#smart_close_popup()."\<C-h>"
  inoremap <expr><Tab>  pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr><C-Space>  pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr><S-Tab>  pumvisible() ? "\<C-p>" : "\<S-Tab>"
  " too slow neosnippet#expandable_or_jumpable()
  " inoremap <expr><Tab> pumvisible() ? "\<C-n>" :
  "       \ neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" :"\<Tab>"
  " inoremap <expr><C-Space>  pumvisible() ? "\<C-n>" :
  "       \ neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" :"\<Tab>"
  " inoremap <expr><S-Tab>  pumvisible() ? "\<C-p>" :
  "       \ neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" :"\<S-Tab>"
  inoremap <expr><C-y>  deoplete#close_popup()
  inoremap <expr><C-e>  deoplete#cancel_popup()
  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  " too slow and https://github.com/Shougo/neosnippet.vim/issues/436#issuecomment-403327057
  " imap <expr><CR> pumvisible() ? deoplete#close_popup() :
  "       \ neosnippet#expandable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<CR>"
  function! s:my_cr_function() abort
    return pumvisible() ? deoplete#close_popup() : "\<CR>"
  endfunction
  command! DeopleteDisable call deoplete#disable()
  command! DeopleteEnable call deoplete#enable()
  call deoplete#custom#option('auto_complete_delay', 20)
  call deoplete#custom#option('auto_refresh_delay', 10)
endif

"-------------------------------
" completor.vim
if s:plug.is_installed('completor.vim')
  let g:completor_gocode_binary = $GOPATH . '/bin/gocode'
  let g:completor_racer_binary = $HOME . '/.cargo/bin/racer'
  inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
  inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<cr>"
endif

"-------------------------------
" vim-racer
if s:plug.is_installed('vim-racer')
  set hidden
  let g:racer_cmd = $HOME . '/.cargo/bin/racer'
  let g:racer_experimental_completer = 1
endif

"-------------------------------
" vim-clang
if s:plug.is_installed('vim-clang')
  let g:clang_c_options = '-std=c11'
  let g:clang_cpp_options = '-std=c++11 -stdlib=libc++'
  " disable auto completion for vim-clang
  let g:clang_auto = 0
  " default 'longest' can not work with neocomplete
  let g:clang_c_completeopt = 'menuone,preview'
  let g:clang_cpp_completeopt = 'menuone,preview'
  if (v:version == 704 && has('patch775')) || v:version >= 705
    let g:clang_c_completeopt .= ',noselect'
    let g:clang_cpp_completeopt .= ',noselect'
  endif
  let g:clang_diagsopt = ''
  " use neocomplete
  " input patterns
  if s:plug.is_installed('neocomplete.vim')
    if !exists('g:neocomplete#force_omni_input_patterns')
      let g:neocomplete#force_omni_input_patterns = {}
    endif
    " for c and c++
    let g:neocomplete#force_omni_input_patterns.c =
          \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
    let g:neocomplete#force_omni_input_patterns.cpp =
          \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
  endif
  let g:clang_enable_format_command = 0
  set nosplitbelow
endif

"-------------------------------
" vim-snowdrop
if s:plug.is_installed('vim-snowdrop')
  let s:libclang_file =
        \ substitute(system("ldconfig -p | grep libclang | awk '{print $4}'"),
        \ '\n\+$', '', '')
  let g:snowdrop#libclang_directory =
        \ substitute(system('dirname ' . s:libclang_file), '\n\+$', '', '')
  let g:snowdrop#libclang_file =
        \ substitute(system('basename ' . s:libclang_file), '\n\+$', '', '')
  let g:snowdrop#command_options = {
        \   'cpp' : '-std=c++11',
        \}
endif

"-------------------------------
" gtags.vim
if s:plug.is_installed('gtags.vim')
  nmap <Leader>] :GtagsCursor<CR>
  nmap [SubLeader]] :Gtags -r <C-r><C-w><CR>
endif

"-------------------------------
" neomake
if s:plug.is_installed('neomake')
  " Auto check
  augroup vimrc_neomake
    autocmd!
    "autocmd! BufWritePost * Neomake
  augroup END
  let g:neomake_error_sign = {'text': 'x', 'texthl': 'NeomakeErrorSign'}
  let g:neomake_warning_sign = {
        \   'text': '!',
        \   'texthl': 'NeomakeWarningSign',
        \ }
  let g:neomake_message_sign = {
        \   'text': '>',
        \   'texthl': 'NeomakeMessageSign',
        \ }
  let g:neomake_info_sign = {'text': 'i', 'texthl': 'NeomakeInfoSign'}
endif

"-------------------------------
" ctrlp.vim
if s:plug.is_installed('ctrlp.vim')
  nnoremap [ctrlp] <Nop>
  nmap [SubLeader]p [ctrlp]
  nnoremap [ctrlp]a <Cmd>CtrlP<Space>
  nnoremap [ctrlp]c <Cmd>CtrlPCurWD<CR>
  nnoremap [ctrlp]b <Cmd>CtrlPBuffer<CR>
  nnoremap [ctrlp]d <Cmd>CtrlPDir<CR>
  nnoremap [ctrlp]f <Cmd>CtrlP<CR>
  nnoremap [ctrlp]l <Cmd>CtrlPLine<CR>
  nnoremap [ctrlp]m <Cmd>CtrlPMRUFiles<CR>
  nnoremap [ctrlp]q <Cmd>CtrlPQuickfix<CR>
  nnoremap [ctrlp]s <Cmd>CtrlPMixed<CR>
  nnoremap [ctrlp]t <Cmd>CtrlPTag<CR>
  let g:ctrlp_clear_cache_on_exit = 0
  let g:ctrlp_mruf_max            = 500
  let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:50'
  let g:ctrlp_map          = '<Leader>p'
  let g:ctrlp_cmd          = 'CtrlPLastMode'
  let g:ctrlp_extensions = ['yankring', 'cmdline', 'funky',
        \ 'tag', 'buffertag', 'undo', 'changes', 'mixed']
  " disable 'modified', 'menu', 'quickfix', 'bookmarkdir', 'dir',
  "         'rtscript', 'line',
endif

"-------------------------------
" jedi-vim
if s:plug.is_installed('jedi-vim')
  let g:jedi#auto_initialization = 1
  let g:jedi#auto_vim_configuration = 1

  nnoremap [jedi] <Nop>
  xnoremap [jedi] <Nop>
  nmap [SubLeader]j [jedi]
  xmap [SubLeader]j [jedi]

  let g:jedi#completions_command = '<C-N>'
  let g:jedi#goto_assignments_command = '[jedi]g'
  let g:jedi#goto_definitions_command = '[jedi]d'
  let g:jedi#documentation_command = '[jedi]K'
  let g:jedi#rename_command = '[jedi]r'
  let g:jedi#usages_command = '[jedi]n'
  let g:jedi#popup_select_first = 0
  let g:jedi#popup_on_dot = 0

  augroup vimrc_jedi
    autocmd!
    autocmd FileType python setlocal completeopt-=preview
    if (v:version == 704 && has('patch775')) || v:version >= 705
      autocmd FileType python setlocal completeopt+=noselect
    endif
  augroup END

  " for w/ neocomplete
  if s:plug.is_installed('neocomplete.vim')
    augroup vimrc_jedi2
      autocmd!
      autocmd FileType python setlocal omnifunc=jedi#completions
    augroup END
    let g:jedi#completions_enabled = 0
    let g:jedi#auto_vim_configuration = 0
    if !exists('g:neocomplete#force_omni_input_patterns')
      let g:neocomplete#force_omni_input_patterns = {}
    endif
    let g:neocomplete#force_omni_input_patterns.python =
          \ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
  endif
endif

"-------------------------------
" neosnippet
if s:plug.is_installed('neosnippet')
  let g:neosnippet#enable_snipmate_compatibility = 1
  let g:neosnippet#enable_completed_snippet = 1
  " let g:neosnippet#enable_complete_done = 1
  let g:neosnippet#expand_word_boundary = 1
  " Plugin key-mappings.
  imap <C-s>     <Plug>(neosnippet_expand_or_jump)
  smap <C-s>     <Plug>(neosnippet_expand_or_jump)
  xmap <C-s>     <Plug>(neosnippet_expand_target)
  " SuperTab like snippets behavior.
  "imap <expr><Tab>
  " \ pumvisible() ? "\<C-n>" :
  " \ neosnippet#expandable_or_jumpable() ?
  " \    "\<Tab>" : "\<Plug>(neosnippet_expand_or_jump)"
  smap <expr><Tab> neosnippet#expandable_or_jumpable() ?
        \ "\<Plug>(neosnippet_expand_or_jump)" : "\<Tab>"
  let g:neosnippet#snippets_directory=[
        \ '~/.vim/snippets',
        \ g:plug_home . '/neosnippet-snippets/neosnippets',
        \ g:plug_home . '/vim-snippets/snippets'
        \ ]
endif

"-------------------------------
" neocomplete
if s:plug.is_installed('neocomplete.vim')
  " 新しく追加した neocomplete の設定
  ""Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
  " Disable AutoComplPop.
  let g:acp_enableAtStartup = 0
  " Use neocomplete.
  let g:neocomplete#enable_at_startup = 1
  " Use smartcase.
  let g:neocomplete#enable_smart_case = 1
  " Set minimum syntax keyword length.
  let g:neocomplete#sources#syntax#min_keyword_length = 3
  let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

  " Define dictionary.
  let g:neocomplete#sources#dictionary#dictionaries = {
        \ 'default' : '',
        \ 'vimshell' : $HOME.'/.vimshell_hist',
        \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

  " Define keyword.
  if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
  endif
  let g:neocomplete#keyword_patterns['default'] = '\h\w*'

  " Plugin key-mappings.
  inoremap <expr><C-g>     neocomplete#undo_completion()
  inoremap <expr><C-l>     neocomplete#complete_common_string()
  " Recommended key-mappings.
  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  function! s:my_cr_function() abort
    "return neocomplete#close_popup() . "\<CR>"
    " For no inserting <CR> key.
    return pumvisible() ? neocomplete#close_popup() : "\<CR>"
  endfunction
  " <Tab>: completion.
  inoremap <expr><Tab>  pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr><S-Tab>  pumvisible() ? "\<C-p>" : "\<S-Tab>"
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
  inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
  inoremap <expr><C-y>  neocomplete#close_popup()
  inoremap <expr><C-e>  neocomplete#cancel_popup()
  " Close popup by <Space>.
  "inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

  " For cursor moving in insert mode(Not recommended)
  "inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
  "inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
  "inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
  "inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"
  " Or set this.
  "let g:neocomplete#enable_cursor_hold_i = 1
  " Or set this.
  "let g:neocomplete#enable_insert_char_pre = 1

  " AutoComplPop like behavior.
  "let g:neocomplete#enable_auto_select = 1

  " Shell like behavior(not recommended).
  "set completeopt+=longest
  "let g:neocomplete#enable_auto_select = 1
  "let g:neocomplete#disable_auto_complete = 1
  "inoremap <expr><Tab>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

  " Enable omni completion.
  augroup vimrc_neocomplete
    autocmd!
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
  augroup END

  " Enable heavy omni completion.
  if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
  endif
  "let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

  " For perlomni.vim setting.
  " https://github.com/c9s/perlomni.vim
  let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
  let g:neocomplete#force_overwrite_completefunc=1
  "
endif

"-------------------------------
" neocomplcache
if s:plug.is_installed('neocomplcache.vim')
  let g:neocomplcache_max_list = 30
  let g:neocomplcache_auto_completion_start_length = 2
  let g:neocomplcache_force_overwrite_completefunc=1

  "Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
  " Disable AutoComplPop.
  let g:acp_enableAtStartup = 0
  " Use neocomplcache.
  let g:neocomplcache_enable_at_startup = 1
  " Use smartcase.
  let g:neocomplcache_enable_smart_case = 1
  " Set minimum syntax keyword length.
  let g:neocomplcache_min_syntax_length = 3
  let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

  " Enable heavy features.
  " Use camel case completion.
  "let g:neocomplcache_enable_camel_case_completion = 1
  " Use underbar completion.
  "let g:neocomplcache_enable_underbar_completion = 1

  " Define dictionary.
  let g:neocomplcache_dictionary_filetype_lists = {
        \ 'default' : '',
        \ 'vimshell' : $HOME.'/.vimshell_hist',
        \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

  " Define keyword.
  if !exists('g:neocomplcache_keyword_patterns')
    let g:neocomplcache_keyword_patterns = {}
  endif
  let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

  " Plugin key-mappings.
  inoremap <expr><C-g>     neocomplcache#undo_completion()
  inoremap <expr><C-l>     neocomplcache#complete_common_string()

  " Recommended key-mappings.
  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  function! s:my_cr_function() abort
    "return neocomplcache#smart_close_popup() . "\<CR>"
    " For no inserting <CR> key.
    return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
  endfunction
  " <Tab>: completion.
  inoremap <expr><Tab>  pumvisible() ? "\<C-n>" : "\<Tab>"
  inoremap <expr><S-Tab>  pumvisible() ? "\<C-p>" : "\<S-Tab>"
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
  inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
  inoremap <expr><C-y>  neocomplcache#close_popup()
  inoremap <expr><C-e>  neocomplcache#cancel_popup()
  " Close popup by <Space>.
  "inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"

  " For cursor moving in insert mode(Not recommended)
  "inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
  "inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
  "inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
  "inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
  " Or set this.
  "let g:neocomplcache_enable_cursor_hold_i = 1
  " Or set this.
  "let g:neocomplcache_enable_insert_char_pre = 1

  " AutoComplPop like behavior.
  "let g:neocomplcache_enable_auto_select = 1

  " Shell like behavior(not recommended).
  "set completeopt+=longest
  "let g:neocomplcache_enable_auto_select = 1
  "let g:neocomplcache_disable_auto_complete = 1
  "inoremap <expr><Tab>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

  " Enable omni completion.
  augroup vimrc_neocomplcache
    autocmd!
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
  augroup END

  " Enable heavy omni completion.
  if !exists('g:neocomplcache_force_omni_patterns')
    let g:neocomplcache_force_omni_patterns = {}
  endif
  let g:neocomplcache_force_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  let g:neocomplcache_force_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplcache_force_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

  " For perlomni.vim setting.
  " https://github.com/c9s/perlomni.vim
  let g:neocomplcache_force_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
endif

"-------------------------------
" unite
if s:plug.is_installed('unite.vim')
  let g:unite_enable_start_insert=1
  let g:unite_source_file_mru_limit = 200
  " The prefix key.
  nnoremap    [unite]   <Nop>
  nmap    <Leader>u [unite]
  " unite.vim keymap
  let g:unite_source_history_yank_enable =1
  nnoremap [unite]u <Cmd>Unite<Space>file<CR>
  nnoremap [unite]g <Cmd>Unite<Space>grep<CR>
  nnoremap [unite]f <Cmd>Unite<Space>buffer<CR>
  nnoremap [unite]b <Cmd>Unite<Space>bookmark<CR>
  nnoremap [unite]a <Cmd>UniteBookmarkAdd<CR>
  nnoremap [unite]m <Cmd>Unite<Space>file_mru<CR>
  nnoremap [unite]h <Cmd>Unite<Space>history/yank<CR>
  nnoremap [unite]r <Cmd>Unite -buffer-name=register register<CR>
  nnoremap [unite]c <Cmd>UniteWithBufferDir -buffer-name=files file<CR>
  nnoremap [SubLeader]vr <Cmd>UniteResume<CR>
  " unite-build map
  nnoremap [SubLeader]vb <Cmd>Unite build<CR>
  nnoremap [SubLeader]vcb <Cmd>Unite build:!<CR>
  nnoremap [SubLeader]vch <Cmd>UniteBuildClearHighlight<CR>
  "let g:unite_source_grep_command = 'ag'
  "let g:unite_source_grep_default_opts = '--nocolor --nogroup'
  "let g:unite_source_grep_max_candidates = 200
  let g:unite_source_grep_recursive_opt = '-rI'
  " unite-grepの便利キーマップ
  vnoremap /g y:Unite grep::-iHRn:<C-R>=escape(@", '\\.*$^[]')<CR><CR>
  nmap <F8> <Cmd>UniteWithCursorWord<Space>grep:%<CR>
  nmap <S-F8> <Cmd>UniteWithCurrentDir<Space>grep<CR>
  nmap <C-F8> <Cmd>UniteWithBufferDir<Space>grep<CR>
  nmap <C-S-F8> <Cmd>UniteWithProjectDir<Space>grep<CR>
  " ファイルを開く時、ウィンドウを分割して開く
  augroup vimrc_unite
    autocmd!
    autocmd FileType unite nnoremap <silent> <buffer> <expr> <C-s> unite#do_action('split')
    autocmd FileType unite inoremap <silent> <buffer> <expr> <C-s> unite#do_action('split')
    " ファイルを開く時、ウィンドウを縦に分割して開く
    autocmd FileType unite nnoremap <silent> <buffer> <expr> <C-v> unite#do_action('vsplit')
    autocmd FileType unite inoremap <silent> <buffer> <expr> <C-v> unite#do_action('vsplit')
    " ESCキーを2回押すと終了する
    autocmd FileType unite nnoremap <buffer> <ESC><ESC> <Cmd>q<CR>
    autocmd FileType unite inoremap <buffer> <ESC><ESC> <Cmd>q<CR>
  augroup END
endif

"-------------------------------
" vim-marching
if s:plug.is_installed('vim-marching')
" clang コマンドの設定
let g:marching_clang_command = 'clang'
" オプションを追加する
" filetype=cpp に対して設定する場合
let g:marching#clang_command#options = {
\   'c'   : '-stdlib=libstdc --pedantic-errors',
\   'cpp' : '-std=c++11 -stdlib=libstdc++ --pedantic-errors'
\}
" インクルードディレクトリのパスを設定
let g:marching_include_paths = filter(copy(split(&path, ',')), "v:val !~? '^$'")
" neocomplete.vim と併用して使用する場合
let g:marching_enable_neocomplete = 1
if !exists('g:neocomplete#force_omni_input_patterns')
let g:neocomplete#force_omni_input_patterns = {}
endif
let g:neocomplete#force_omni_input_patterns.cpp =
\ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
" 処理のタイミングを制御する
" 短いほうがより早く補完ウィンドウが表示される
" ただし、marching.vim 以外の処理にも影響するので注意する
set updatetime=100
" オムニ補完時に補完ワードを挿入したくない場合
imap <buffer> <C-x><C-o> <Plug>(marching_start_omni_complete)
" キャッシュを削除してからオムに補完を行う
imap <buffer> <C-x><C-x><C-o> <Plug>(marching_force_start_omni_complete)
" 非同期ではなくて、同期処理でコード補完を行う場合
" この設定の場合は vimproc.vim に依存しない
" let g:marching_backend = 'sync_clang_command'
endif

"-------------------------------
" vim-tags
if s:plug.is_installed('vim-tags')
let g:vim_tags_auto_generate = 1
let g:vim_tags_use_vim_dispatch = 0
endif

"-------------------------------
" syntastic
if s:plug.is_installed('syntastic')
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_enable_signs = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_check_on_save = 1
endif

"-------------------------------
" SrcExpl
nmap <F8> <Cmd>SrcExplToggle<CR>
let g:SrcExpl_winHeight = 8
let g:SrcExpl_refreshTime = 100
let g:SrcExpl_gobackKey = "<SPACE>"
let g:SrcExpl_pluginList = [
        \ "__Tag_List__",
        \ "NERD_tree_1",
        \ "[quickrun output]",
        \ "[unite] - default",
        \ "vimfiler:default",
        \ "ControlP",
        \ "Source_Explorer"
        \ ]
let g:SrcExpl_searchLocalDef = 0
let g:SrcExpl_isUpdateTags = 0
let g:SrcExpl_updateTagsKey = "<F12>"
let g:SrcExpl_updateTagsCmd = "ctags --sort=foldcase -R ."

"-------------------------------
" Trinity
nmap <F8>   <Cmd>TrinityToggleAll<CR>
nmap <F9>   <Cmd>TrinityToggleSourceExplorer<CR>
nmap <F10>  <Cmd>TrinityToggleTagList<CR>
nmap <F11>  <Cmd>TrinityToggleNERDTree<CR>
nmap <C-j> <C-]>

"-------------------------------
" Taglist
if s:plug.is_installed('Taglist')
  echo "a"
let Tlist_Show_One_File = 1                   " 現在表示中のファイルのみのタグしか表示しない
let Tlist_Exit_OnlyWindow = 1                 " taglistのウインドウだけならVimを閉じる
let Tlist_WinWidth = 50
endif

"-------------------------------
" im_control.vim
if s:plug.is_installed('im_control.vim')
" 「日本語入力固定モード」切替キー
inoremap <silent> <C-j> <C-r>=IMState('FixMode')<CR>
" PythonによるIBus制御指定
let IM_CtrlIBusPython = 1

" <ESC>押下後のIM切替開始までの反応が遅い場合はttimeoutlenを短く設定してみてください。
set timeout timeoutlen=3000 ttimeoutlen=10
endif


"===============================
" lightline                  {{{
"===============================
  "-------------------------------
  " Disable configs
  " syntastic
  "      \ 'component_expand': {
  "      \   'syntastic': 'SyntasticStatuslineFlag',
  "      \ },
  "      \ 'component_type': {
  "      \   'syntastic': 'error',
  "      \ },

  " augroup vimrc_syntastic
  " autocmd!
  " autocmd BufWritePost *.c,*.cpp,*.cc call s:syntastic()
  " augroup END
  " function! s:syntastic() abort
  " SyntasticCheck
  " call lightline#update()
  " endfunction

  " function! LightLineGitGutter() abort
  "   if ! exists('*GitGutterGetHunkSummary')
  "         \ || ! get(g:, 'gitgutter_enabled', 0)
  "         \ || winwidth('.') <= 90
  "     return ''
  "   endif
  "   let symbols = [
  "         \ g:gitgutter_sign_added . ' ',
  "         \ g:gitgutter_sign_modified . ' ',
  "         \ g:gitgutter_sign_removed . ' '
  "         \ ]
  "   let hunks = GitGutterGetHunkSummary()
  "   let ret = []
  "   for i in [0, 1, 2]
  "     if hunks[i] > 0
  "       call add(ret, symbols[i] . hunks[i])
  "     endif
  "   endfor
  "   return join(ret, ' ')
  " endfunction

  " let g:tagbar_status_func = 'TagbarStatusFunc'
  "
  " function! TagbarStatusFunc(current, sort, fname, ...) abort
  "   let g:lightline.fname = a:fname
  "   return lightline#statusline(0)
  " endfunction

  " function! LightLineFugitive() abort
  "   try
  "     if s:is_ignore_status()
  "       let mark = ''  " edit here for cool mark
  "       let branch = fugitive#head()
  "       return branch !=# '' ? mark.branch : ''
  "     endif
  "   catch
  "   endtry
  "   return ''
  " endfunction

  " function! CtrlPMark() abort
  "   if expand('%:t') =~? 'ControlP' && has_key(g:lightline, 'ctrlp_item')
  "     call lightline#link('iR'[g:lightline.ctrlp_regex])
  "     return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
  "           \ , g:lightline.ctrlp_next], 0)
  "   else
  "     return ''
  "   endif
  " endfunction

  " let g:ctrlp_status_func = {
  "       \ 'main': 'CtrlPStatusFunc_1',
  "       \ 'prog': 'CtrlPStatusFunc_2',
  "       \ }
  "
  " function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked) abort
  "   let g:lightline.ctrlp_regex = a:regex
  "   let g:lightline.ctrlp_prev = a:prev
  "   let g:lightline.ctrlp_item = a:item
  "   let g:lightline.ctrlp_next = a:next
  "   return lightline#statusline(0)
  " endfunction
  "
  " function! CtrlPStatusFunc_2(str) abort
  "   return lightline#statusline(0)
  " endfunction

  " function! AleError() abort
  "   return s:ale_string(0)
  " endfunction
  "
  " function! AleWarning() abort
  "   return s:ale_string(1)
  " endfunction
  "
  " function! AleOk() abort
  "   return s:ale_string(2)
  " endfunction
  "
  " function! s:ale_string(mode) abort
  "   if !exists('g:ale_buffer_info')
  "     return ''
  "   endif
  "
  "   let g:ale_statusline_format = ['Err' .' %d', 'Warn' . ' %d', 'OK' . '  ']
  "
  "   let l:buffer = bufnr('%')
  "   let [l:error_count, l:warning_count] = ale#statusline#Count(l:buffer)
  "   let [l:error_format, l:warning_format, l:no_errors] = g:ale_statusline_format
  "
  "   if a:mode == 0 " Error
  "     return l:error_count ? printf(l:error_format, l:error_count) : ''
  "   elseif a:mode == 1 " Warning
  "     return l:warning_count ? printf(l:warning_format, l:warning_count) : ''
  "   endif
  "
  "   return l:error_count == 0 && l:warning_count == 0 ? l:no_errors : ''
  " endfunction
  "
  " augroup vimrc_lightline_on_ale
  "   autocmd!
  "   autocmd User ALELint call lightline#update()
  " augroup END


"===============================
" lightline                  {{{
"===============================

if IsPluginInstalled('lightline.vim')
  let g:lightline = {
        \ 'enable': {
        \   'statusline': 1,
        \   'tabline': 0,
        \ },
        \ 'component_function': {
        \   'git_branch': 'LightLineCocGitBranch',
        \   'git_status': 'LightLineCocGitStatus',
        \   'root_dir': 'LightLineRootDir',
        \   'filename': 'LightLineFilename',
        \   'fileformat': 'LightLineFileformat',
        \   'filetype': 'LightLineFiletype',
        \   'fileencoding': 'LightLineFileencoding',
        \   'quickfix_title': 'LightLineQuickfixTitle',
        \   'filesize': 'FileSizeForHuman',
        \   'mode': 'LightLineMode',
        \   'cocstatus': 'coc#status',
        \   'git_blame': 'LightLineCocGitBlame',
        \   'currentfunction': 'CocOrVistaCurrentFunction',
        \   'vista_method': 'NearestMethodOrFunction',
        \ },
        \ 'subseparator': { 'left': '|', 'right': '|' }
        \ }
  let s:lightline_mode1 = {
        \   'left': [
        \              ['mode', 'paste'],
        \              ['filename'],
        \              ['currentfunction', 'quickfix_title']
        \   ],
        \   'right': [
        \              ['lineinfo'],
        \              ['git_status'],
        \              ['cocstatus']
        \   ]
        \ }
  let s:lightline_mode2 = {
        \   'left': [
        \              ['mode', 'paste'],
        \              ['filename'],
        \              ['root_dir', 'git_branch', 'git_blame'],
        \   ],
        \   'right': [
        \              ['lineinfo'],
        \              ['filesize', 'percent'],
        \              ['fileformat', 'fileencoding', 'filetype'],
        \   ]
        \ }
  let g:lightline.active = s:lightline_mode1
  let g:lightline.tab = {
       \ 'active': [ 'tabnum', 'filename', 'modified' ],
       \ 'inactive': [ 'tabnum', 'filename', 'modified' ] }
  if exists('s:lightline_colorscheme')
    let g:lightline.colorscheme = s:lightline_colorscheme
  else
    let g:lightline.colorscheme = 'wombat'
  endif

  nnoremap ! <Cmd>call LightLineToggle()<CR>
  function! LightLineToggle() abort
    let g:lightline.active = g:lightline.active ==# s:lightline_mode1 ? s:lightline_mode2 : s:lightline_mode1
    call lightline#init()
    call lightline#update()
    " Rerender the tabline because lightline's tabline set is faster than barbar
    if exists("*bufferline#render")
      let &tabline = bufferline#render(v:true)
    endif
  endfunction

  function! LightLineModified() abort
    return &ft =~? 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
  endfunction

  function! LightLineReadonly() abort
    return &ft !~? 'help' && &readonly ? 'RO' : ''
  endfunction

  function! LightLineMode() abort
    let fname = expand('%:t')
    return fname ==? '__vista__' ? 'Vista' :
          \ fname ==? '__Gundo__' ? 'Gundo' :
          \ fname ==? '__Gundo_Preview__' ? 'Gundo Preview' :
          \ fname =~? 'buffergator-buffers' ? 'BufferGator' :
          \ (&ft ==? 'qf' && getwininfo(win_getid())[0].loclist) ? 'Location' :
          \ &ft ==? 'qf' ? 'QuickFix' :
          \ &ft ==? 'defx' ? 'Defx' :
          \ &ft ==? 'coc-explorer' ? '' :
          \ winwidth(0) > 30 ? lightline#mode() : ''
  endfunction

  function! LightLineRootDir() abort
    if winwidth(0) > 150
      return fnamemodify(getcwd(), ':t')
    endif
    return ''
  endfunction

  function! LightLineFilename() abort
    if winwidth(0) < 50
      let fname = expand('%:t')
    elseif winwidth(0) > 150
      let fname = expand('%')
    else
      let fname = pathshorten(expand('%'))
    endif
    return fname ==? '__vista__' ? '' :
          \ fname =~? '__Gundo\|NERD_tree' ? '' :
          \ &ft ==? 'qf' ? g:asyncrun_status :
          \ &ft ==? 'fern' ? 'Fern' :
          \ &ft ==? 'defx' ? 'Defx' :
          \ &ft ==? 'undotree' ? (exists('*t:undotree.GetStatusLine') ? t:undotree.GetStatusLine() : fname) :
          \ &ft ==? 'coc-explorer' ? 'coc-explorer' :
          \ ('' !=? LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
          \ ('' !=? fname ? fname : '[No Name]') .
          \ ('' !=? LightLineModified() ? ' ' . LightLineModified() : '')
  endfunction

  function! LightLineQuickfixTitle() abort
    return exists('w:quickfix_title') ? w:quickfix_title : ''
  endfunction

  function! LightLineFugitive() abort
    try
      if &ft !~? 'help\|gundo\|diff' && exists('g:loaded_fugitive')
        let mark = ''  " edit here for cool mark
        let branch = fugitive#head()
        return branch !=# '' ? mark.branch : ''
      endif
    catch
    endtry
    return ''
  endfunction

  " function! LightLineGinaBranch()
  "   if &ft !~? 'help\|gundo\|diff' && exists('g:loaded_gina')
  "     return gina#component#repo#branch()
  "   endif
  "   return ''
  " endfunction

  " function! LightLineGinaStatus()
  "   if &ft !~? 'help\|gundo\|diff' && exists('g:loaded_gina')
  "     return gina#component#status#preset()
  "   endif
  "   return ''
  " endfunction

  function! LightLineFileformat() abort
    return winwidth(0) > 70 ? &fileformat : ''
  endfunction

  function! LightLineFiletype() abort
    return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
  endfunction

  function! LightLineFileencoding() abort
    return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
  endfunction

  augroup vimrc_gutentags_status_line_refresher
    autocmd!
    autocmd User GutentagsUpdating call lightline#update()
    autocmd User GutentagsUpdated call lightline#update()
  augroup END

  function! LightLineCocGitBranch() abort
    return winwidth(0) > 90 ? get(g:,'coc_git_status','') : ''
  endfunction

  function! LightLineCocGitStatus() abort
    let l:status = substitute(
          \ substitute(get(b:, 'coc_git_status', ''), ' *', '', ''),
          \ ' *$', '', '')
    return winwidth(0) > 90 ? l:status : ''
  endfunction

  function! LightLineCocGitBlame() abort
    let l:blame = get(b:, 'coc_git_blame', '')
    if l:blame ==? 'File not indexed'
      let l:blame = ''
    endif
    return winwidth(0) > 90 ? l:blame : ''
  endfunction

  function! FileSizeForHuman() abort
    let l:bytes = line2byte('$') + len(getline('$'))
    let l:sizes = ['', 'K', 'M', 'G']
    let l:i = 0
    while l:bytes >= 1024
      let l:bytes = l:bytes / 1024.0
      let l:i += 1
    endwhile
    return printf('%.1f%s', l:bytes, l:sizes[l:i])
  endfun

  let g:unite_force_overwrite_statusline = 0
  let g:vimfiler_force_overwrite_statusline = 0
  let g:vimshell_force_overwrite_statusline = 0
  set noshowmode

  function! SwitchLightlineColorScheme(color) abort
    let g:lightline.colorscheme = a:color
    call lightline#init()
    call lightline#colorscheme()
    call lightline#update()
  endfunction

  function! CocCurrentFunction() abort
    return get(b:, 'coc_current_function', '')
  endfunction

  function! CocOrVistaCurrentFunction() abort
    let l:func_name = get(b:, 'coc_current_function', '')
    if l:func_name ==? ''
      return get(b:, 'vista_nearest_method_or_function', '')
    endif
    return l:func_name
  endfunction

endif

" }}}


" }}}

